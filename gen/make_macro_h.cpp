#include <cstdlib>
#include <cstring>
#include <fstream>
#include <functional>
#include <iostream>
#include <string>
#include <sstream>
#include <type_traits>
#include <vector>

#pragma GCC diagnostic ignored "-Wpragmas" // Silence GCC warning about the next line disabling a warning that GCC doesn't have.
#pragma GCC diagnostic ignored "-Wstring-plus-int" // Silence clang warning about `1+R"()"` pattern.

#define VERSION "1.0.2"

namespace data
{
    constexpr int n = 64;
    const std::vector<std::string> suffixes = {"", "_A"};
}

namespace impl
{
    std::ofstream output_file;

    std::stringstream ss;
    const std::stringstream::fmtflags stdfmt = ss.flags();

    bool at_line_start = 1;
    int indentation = 0;
    int section_depth = 0;

    constexpr const char *indentation_string = "    ";

    void init(int argc, char **argv)
    {
        if (argc < 2)
        {
            std::cout << "Expected output file name.";
            std::exit(-1);
        }
        if (argc > 2)
        {
            std::cout << "Invalid usage.";
            std::exit(-1);
        }

        output_file.open(argv[1]);
        if (!output_file)
        {
            std::cout << "Unable to open `" << argv[1] << "`.\n";
            std::exit(-1);
        }
    }
}

template <typename ...P> [[nodiscard]] std::string make_str(const P &... params)
{
    impl::ss.clear();
    impl::ss.str("");
    impl::ss.flags(impl::stdfmt);
    (impl::ss << ... << params);
    return impl::ss.str();
}

void output_str(const std::string &str)
{
    for (const char *ptr = str.c_str(); *ptr; ptr++)
    {
        char ch = *ptr;

        if (ch == '}' && impl::indentation > 0)
            impl::indentation--;

        if (impl::at_line_start)
        {
            if (std::strchr(" \t\r", ch))
                continue;

            for (int i = 0; i < impl::indentation; i++)
                impl::output_file << impl::indentation_string;
            impl::at_line_start = 0;
        }

        impl::output_file.put(ch == '$' ? ' ' : ch);

        if (ch == '{')
            impl::indentation++;

        if (ch == '\n')
            impl::at_line_start = 1;
    }
}

template <typename ...P> void output(const P &... params)
{
    output_str(make_str(params...));
}

void section(std::string header, std::function<void()> func)
{
    output(header, "\n{\n");
    func();
    output("}\n");
}
void section_sc(std::string header, std::function<void()> func) // 'sc' stands for 'end with semicolon'
{
    output(header, "\n{\n");
    func();
    output("};\n");
}

void decorative_section(std::string name, std::function<void()> func)
{
    output("//{", std::string(impl::section_depth+1, ' '), name, "\n");
    impl::indentation--;
    impl::section_depth++;
    func();
    impl::section_depth--;
    output("//}", std::string(impl::section_depth+1, ' '), name, "\n");
    impl::indentation++;
}

void next_line()
{
    output("\n");
}

int main(int argc, char **argv)
{
    impl::init(argc, argv);

    { // Header
        output(1+R"(
            // macro.h
            // Preprocessor utils
            // Version )", VERSION, R"(
            // Autogenerated, don't touch.

            #pragma once
        )");
        next_line();
    }

    { // Macros
        { // To string
            output("#define MA_STR(...) MA_STR_impl(__VA_ARGS__)\n");
            output("#define MA_STR_impl(...) #__VA_ARGS__\n");
        }

        next_line();

        { // Concatenation
            output("#define MA_CAT(x,y) MA_CAT_impl(x,y)\n");
            output("#define MA_CAT_impl(x,y) x##y\n");
        }

        next_line();

        { // Misc
            output(1+R"(
                #define MA_NULL(...)
                #define MA_IDENTITY(...) __VA_ARGS__

                #define MA_COMMA() ,
                #define MA_SEMICOLON() ;
                #define MA_PLUS() +

                #define MA_OVERLOAD(name, ...) MA_CAT(name, MA_VA_SIZE(__VA_ARGS__))(__VA_ARGS__)
            )");
        }

        next_line();

        { // Call a macro (this is intended for use outside of this header only, since it can't be used recursively and we want to be extra safe)
            for (const auto &suffix : data::suffixes)
                output("#define MA_CALL", suffix, "(macro, ...) macro(__VA_ARGS__)\n");
            for (const auto &suffix : data::suffixes)
                output("#define MA_IMPL_CALL", suffix, "(macro, ...) macro(__VA_ARGS__) // For implementation use\n");
        }

        next_line();

        { // Sequence access
            output(1+R"(
                #define MA_SEQ_FIRST(seq) MA_SEQ_FIRST_impl seq )
                #define MA_SEQ_FIRST_impl(...) __VA_ARGS__ MA_NULL(

                #define MA_SEQ_NO_FIRST(seq) MA_NULL seq
            )");
        }

        next_line();

        { // Variadic size
            output("#define MA_VA_SIZE(...) MA_VA_SIZE_impl(__VA_ARGS__");
            for (int i = data::n+1; i >= 0; i--) // Note that the loop goes up to n+1. This is to simplify support for the trailing comma for MA_VA_TO_SEQ.
                output(",", i);
            output(")\n");

            output("#define MA_VA_SIZE_impl(");
            for (int i = 1; i <= data::n+1; i++)
                output("p", i, ",");
            output("size,...) size\n");
        }

        next_line();

        { // Sequence size
            output("#define MA_SEQ_SIZE(seq) MA_CAT(MA_SEQ_SIZE_impl_0 seq, _val)\n");
            for (int i = 0; i <= data::n; i++)
                output("#define MA_SEQ_SIZE_impl_", i, "(...) MA_SEQ_SIZE_impl_", i+1, "\n");
            for (int i = 0; i <= data::n; i++)
                output("#define MA_SEQ_SIZE_impl_", i, "_val ", i, "\n");
        }

        next_line();

        { // Variadic to sequence
            output("#define MA_VA_TO_SEQ(...) MA_CAT(MA_VA_TO_SEQ_impl_, MA_VA_SIZE(__VA_ARGS__,))(__VA_ARGS__,)\n");
            output("#define MA_VA_TO_SEQ_TRAILING_COMMA(...) MA_CAT(MA_VA_TO_SEQ_impl_, MA_VA_SIZE(__VA_ARGS__))(__VA_ARGS__)\n");
            output("#define MA_VA_TO_SEQ_impl_null\n");
            output("#define MA_VA_TO_SEQ_impl_1(empty) MA_VA_TO_SEQ_impl_null##empty // If you get a error message pointing to this line, you forgot a trailing comma somewhere.\n");
            for (int i = 1; i <= data::n; i++)
            {
                output("#define MA_VA_TO_SEQ_impl_", i+1, "("); // Note that the last macro generated by this line will have number n+1. This is intended, since there is one extra empty argument for the trailing comma.
                for (int j = 1; j <= i; j++)
                    output("p", j, ",");
                output("empty) ");
                for (int j = 1; j <= i; j++)
                    output("(p", j, ")");
                output(" MA_VA_TO_SEQ_impl_1(empty)\n");
            }
        }

        next_line();

        { // Sequence to variadic
            output("#define MA_SEQ_TO_VA(seq) MA_CAT(MA_SEQ_TO_VA_impl_, MA_SEQ_SIZE(seq)) seq\n");
            output("#define MA_SEQ_TO_VA_impl_0\n");
            output("#define MA_SEQ_TO_VA_impl_1(...) __VA_ARGS__\n");
            for (int i = 2; i <= data::n; i++)
                output("#define MA_SEQ_TO_VA_impl_", i, "(...) __VA_ARGS__,MA_SEQ_TO_VA_impl_", i-1, "\n");
        }

        next_line();

        { // Sequence to variadic (preserve parens)
            output("#define MA_SEQ_TO_VA_PARENS(seq) MA_CAT(MA_SEQ_TO_VA_PARENS_impl_, MA_SEQ_SIZE(seq)) seq\n");
            output("#define MA_SEQ_TO_VA_PARENS_impl_0\n");
            output("#define MA_SEQ_TO_VA_PARENS_impl_1(...) (__VA_ARGS__)\n");
            for (int i = 2; i <= data::n; i++)
                output("#define MA_SEQ_TO_VA_PARENS_impl_", i, "(...) (__VA_ARGS__),MA_SEQ_TO_VA_PARENS_impl_", i-1, "\n");
        }

        next_line();

        { // For each variadic element
            output("// In MA_*_FOR_EACH below, `macro` argument is called as `macro(i, data, element)`. Note that to simplify implementation, `i` counts backwards from N-1 to 0.\n");

            next_line();

            for (const auto &suffix : data::suffixes)
            {
                output("#define MA_VA_FOR_EACH", suffix, "(macro, sep, data, ...) MA_SEQ_FOR_EACH", suffix, "(macro, sep, data, MA_VA_TO_SEQ(__VA_ARGS__))\n");
                output("#define MA_VA_FOR_EACH", suffix, "_TRAILING_COMMA(macro, sep, data, ...) MA_SEQ_FOR_EACH", suffix, "(macro, sep, data, MA_VA_TO_SEQ_TRAILING_COMMA(__VA_ARGS__))\n");
            }
        }

        next_line();

        { // For each sequence element
            bool first = 1;
            for (const auto &suffix : data::suffixes)
            {
                if (first)
                    first = 0;
                else
                    next_line();

                output("#define MA_SEQ_FOR_EACH", suffix, "(macro, sep, data, seq) MA_CAT(MA_SEQ_FOR_EACH", suffix, "_impl_, MA_SEQ_SIZE(seq))(macro, sep, data, seq)\n");
                output("#define MA_SEQ_FOR_EACH", suffix, "_impl_0(macro, sep, data, seq)\n");
                output("#define MA_SEQ_FOR_EACH", suffix, "_impl_1(macro, sep, data, seq) MA_IMPL_CALL", suffix, "(macro, 0, data, MA_SEQ_FIRST(seq))\n"); // Do not use IDENTITY instead of SEQ_FIRST here! Doing so might break it in the parameter macro.
                for (int i = 2; i <= data::n; i++)
                    output("#define MA_SEQ_FOR_EACH", suffix, "_impl_", i, "(macro, sep, data, seq) "
                           "MA_IMPL_CALL", suffix, "(macro, ", i-1, ", data, MA_SEQ_FIRST(seq)) sep() MA_SEQ_FOR_EACH", suffix, "_impl_", i-1, "(macro, sep, data, MA_SEQ_NO_FIRST(seq))\n");
            }
        }
    }

    next_line();

    if (!impl::output_file)
        return -1;
}
